########################
# astar_fibheap.py
#
# An A* search-problem class utilizing a Fibonacci heap
# for the decrease-key operations.

# Subclass AStar for your specific problem domain!
#
# Written: Mark Wilson
# Based on code by Ikhyun Park
########################

"""This is the astar_fibheap module.  It defines classes for an A* search
problem and nodes in the search tree.  This module uses
the fibheap.FibonacciHeap type for the search's priority-queue fringe.

Note that the AStar class must be subclassed for a specific problem domain!"""

import weakref
import sys
import traceback

import fibheap


##############################
#
# AStarNode
#
# A node in the A* search tree.  Stores heuristic value (h), cost-from-start
# value (g), overall cost value (f=h+g), a node id, an associated search state,
# a parent node, and a list of children
#
class AStarNode:
	"""A node in the A* search tree.  Stores heuristic value (h),
	cost-from-start value (g), overall cost value (f=h+g), a node id, an
	associated search state, a parent node, and a list of children.  Users'
	interaction with this type should be fairly limited, the only necessary
	direct uses being:

	-Storing a reference to an AStarNode associated with a given search state,
	for tracking visited states (see documentation on AStar for overriding
	its visit(), visited_state_node(), and clear_visited() methods).
	-Inspecting nodes along the final path from start to goal, as returned by
	AStar's result_path() method.

	To retrieve the state stored in an AStarNode, you can access its "state"
	data member."""

	def __init__(self, f=0, h=0, g=0, nid=0, state=None, parent=None,
				children=None, expanded=False):
		self.f = f
		self.h = h
		self.g = g
		self.nid = nid
		self.state = state
		# Since parent holds a ref to children, we want a weak reference
		self.parent = weakref.proxy(parent) if parent else None
		# Can't do children=[] in parameter list as all nodes wind up with
		# the same list
		self.children = children if children else []
		self.expanded = expanded





#########################
# AStar
#
#
# An A* search problem instance.
#
# This is a generic class definition.  You should subclass it and override
# the is_goal(), successors(), clear_visited(), visit(), visited_state_node(),
# and heuristic() methods, as well as defining some kind of state class that
# represents a state in your search problem.
#
# Do call this class's __init__() in your subclass's, but make sure you can
# handle calls to clear_visited() and visit() before you do.
#
class AStar:
	"""An A* search problem instance.  A* search proceeds over states in the
	search space and stores visited states in tree nodes represented as
	AStarNode instances.  State types are defined by the user, but the user
	must be able to compare newly-generated states to old states to avoid
	revisiting states.  This class is intended to be subclassed by the user for
	a specific search space.  The following methods should be overridden:

	--is_goal()
	--successors()
	--clear_visited()
	--visit()
	--visited_state_node()
	--heuristic()

	NB:  The AStar.__init__() constructor should definitely be called by the
	subclass, but be prepared for it to call clear_visited() and visit()!  This
	means that whatever structure you need for tracking visited states
	should already be in place or should be initialized if necessary by those
	methods.

	After initialization, you can call search_step() to perform one step of the
	A* search, or search() to do a whole search to completion or failure.  Either
	will return True if a goal has been reached and False otherwise.

	After a successful search, you may inspect the data member "goal" to see
	the goal state and call result_path() for a list of AStarNode objects
	from start to goal.  You may also call num_nodes() for the total number
	of nodes in the search tree."""


	def __init__(self, state, testGoalOnGeneration=False):
		"""Initializes a search with the given start state (a user-defined
		type).  If testGoalOnGeneration is True, then goal conditions will be
		tested on new states as soon as they are generated by the successors()
		method.  This may end the search more quickly but may also give
		sub-optimal results."""
		self.testGoalOnGeneration = testGoalOnGeneration
		self.set_start(state)

	def set_start(self, start):
		"""Sets the given state as the start state for the search and
		initializes the search tree and parameters."""
		# Reset the list of visited states
		self.clear_visited()

		self.fringe = fibheap.FibonacciHeap()
		# We don't have a goal node or a path to it yet
		self.goal = None
		self.path = []
		# Start with node id 0
		self.nid = 0

		if self.testGoalOnGeneration and self.is_goal(start):
			self.goal = start
			self.path.append(start)
			return

		# Set up a search-tree node for the start state
		self.root = self.add_successor(None, start, 0)

	def search(self):
		"""Run a search to completion or failure.  Return True if a solution
		is found, or False on failure."""
		while not self.fringe.is_empty():
			res = self.search_step()
			if res:
				return True
		return False

	def search_step(self):
		"""Perform one step of an A* search.  Return True if a goal state is
		found, False otherwise.  A step is defined as removing one node from
		the fringe, generating its successors, testing the node or its
		successors for goal conditions (depending on the value of
		testGoalOnGeneration when the AStar object was created), and appending
		the successors to the priority-queue search fringe."""
		if self.fringe.is_empty():
			return False

		# Get the fringe node with the minimal key and extract our search state
		n = self.fringe.extract_minimum()[1]

		# Check goal condition
		if (not self.testGoalOnGeneration) and self.is_goal(n.state):
				self.goal = n
				while n != None:
					self.path.append(n.state)
					n = n.parent
				self.path.reverse()
				return True

		# Generate successors and mark state expanded
		successors, costs = self.successors(n.state)
		n.expanded = True

		# Do some tests on the successors
		for succ, cost in zip(successors, costs):
			# Goal test if appropriate
			if self.testGoalOnGeneration and self.is_goal(succ):
					self.goal = succ
					while succ != None:
						self.path.append(succ.state)
						succ = succ.parent
					self.path.reverse()
					return True

			# Check to see if the state has been visited before in the search
			visited = self.visited_state_node(succ)
			# State was visited before, check its cost
			if visited:
				# This is a longer path from the start to this state than
				# before, so ignore this successor
				if n.g + cost >= visited.data.g:
					continue
				# This is a shorter path to this state than before, so
				# adjust its value in the fringe
				else:
					# First, remove the prior instance from the fringe
					try:
						self.fringe.delete(visited)
					except (Exception) as e:
						print "Deleting from fringe failed.  "\
								"Heuristic inadmissible or inconsistent?"
						print e
						traceback.print_exc()
					# Second, add the new version of the state
					self.add_successor(n,succ,cost)
			# This state hasn't been visited before, so just add it
			else:
				self.add_successor(n,succ,cost)

		return False

	# Add a successor to the given parent.  The state is contained in a new
	# node with the given cost from parent to child.  The new child is returned.
	def add_successor(self, parent, state, cost):
		"""An internal operation.  The user should NOT call this method.
		Adds a new node to the search tree with the given parent."""

		# Set up a new node as a child of the parent
		g = parent.g + cost if parent else 0
		h = self.heuristic(state)
		f = h+g
		child = AStarNode(f,h,g,self.nid,state,parent)
		self.nid += 1
		if parent:
			parent.children.append(child)
		# Put it in the fringe
		# Tuples are sorted lexicographically, so nodes are sorted by
		#  f-score first, then h-score, then g-score.
		heapNode = self.fringe.insert( (f,h,g), child )
		# Mark this state visited and map it to the new search node
		self.visit(state, heapNode)

		return child

	def num_nodes(self):
		"""Returns the number of nodes in the search tree."""
		return 1 + self.num_descendents(self.root)

	def num_descendents(self, node):
		"""Internal function.  Returns the number of descendents of the given
		search-tree node.  Users can call but there isn't much reason to."""
		count = len(node.children)
		for child in node.children:
			count += self.num_descendents(child)
		return count

	def result_path(self):
		"""Returns a list containing AStarNode instances from the start to the
		goal.  Will be empty unless a successful search has been run."""
		return self.path




	##################################
	# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	#
	# The following should be overloaded by a subclass!
	#

	def is_goal(self, state):
		"""Returns True if the given state is a goal, otherwise False.
		Internal; users may call this method but have little reason to.
		Abstract in this definition; should be overloaded by a subclass."""
		pass

	def successors(self, state):
		"""Returns a tuple containing two lists:
		- A list of all legal successor states to the given state.
		- A list of corresponding costs to move to those states.
		Internal; users may call this method but have little reason to.
		Abstract in this definition; should be overloaded by a subclass."""
		pass

	def clear_visited(self):
		"""Clears the list of visited states and their mappings to AStarNode
		instances.  See visit() and visited_state_node().  Internal; users
		should NEVER call this method.  Abstract in this
		definition; should be overloaded by a subclass."""
		pass

	def visit(self, state, node):
		"""Marks the given state as visited and maps it to a given AStarNode.
		See visited_state_node() and clear_visited().  Internal; users should
		NEVER call this method.  Abstract in this
		definition; should be overloaded by a subclass."""
		pass

	def visited_state_node(self, state):
		"""If the given state has been visited, returns the associated
		AStarNode.  Otherwise, returns None.  See visit() and clear_visited().
		Internal; users may call this method but have little reason to.
		Abstract in this definition; should be overloaded by a subclass."""
		pass

	def heuristic(self, state):
		"""Returns a heuristic value for the given state.  This heuristic
		should ideally fulfill the requirements for admissibility and
		consistency.  Internal; users may call this method but have little
		reason to.  Abstract in this definition; should be overloaded by
		a subclass."""
		return 0
